#!/usr/bin/env bash
set -euo pipefail

MATERIAL_PATH="${1:-${MATERIAL_PATH_ENV:-$HOME/.config/wallpaper/material.json}}"
KITTY_CONF="${KITTY_CONF_PATH_ENV:-$HOME/.config/kitty/kitty.conf}"
THEME_PATH="${KITTY_THEME_PATH_ENV:-$HOME/.config/kitty/quickshell-theme.conf}"
KITTY_SOCKET="${KITTY_SOCKET_ENV:-}"
KITTY_BIN="${KITTY_BIN_ENV:-}"

export PATH="/usr/local/bin:/usr/bin:/bin:${PATH:-}"

BEGIN_MARKER="# BEGIN_QUICKSHELL_THEME_SYNC"
END_MARKER="# END_QUICKSHELL_THEME_SYNC"

need_cmd() {
  command -v "$1" >/dev/null 2>&1 || {
    echo "Error: required command not found: $1" >&2
    exit 127
  }
}

need_cmd jq

if [[ ! -f "$MATERIAL_PATH" ]]; then
  echo "Material file not found: $MATERIAL_PATH" >&2
  exit 1
fi

if [[ ! -f "$KITTY_CONF" ]]; then
  echo "Kitty config not found: $KITTY_CONF" >&2
  exit 0
fi

use_dark=$(jq -r 'if (.is_dark_mode == true) or (.mode == "dark") then "true" else "false" end' "$MATERIAL_PATH")

pick_color() {
  local role="$1"
  local fallback="$2"
  if [[ "$use_dark" == "true" ]]; then
    jq -r --arg role "$role" --arg fallback "$fallback" '.colors[$role].dark // $fallback' "$MATERIAL_PATH"
  else
    jq -r --arg role "$role" --arg fallback "$fallback" '.colors[$role].light // $fallback' "$MATERIAL_PATH"
  fi
}

background=$(pick_color background "#201f25")
foreground=$(pick_color on_primary_container "#e5e1e9")
on_primary=$(pick_color on_primary "#ffffff")
selection_bg=$(pick_color primary_container "#c7bfff")
selection_fg=$(pick_color on_primary_container "#1a1a1a")
cursor=$(pick_color primary "#c7bfff")
outline=$(pick_color outline "#928f99")
outline_variant=$(pick_color outline_variant "#928f99")
primary=$(pick_color primary "#c7bfff")
secondary=$(pick_color secondary "#9aa0a6")
tertiary=$(pick_color tertiary "#8aa37c")
error=$(pick_color error "#ff6b6b")
secondary_container=$(pick_color secondary_container "$secondary")
tertiary_container=$(pick_color tertiary_container "$tertiary")
error_container=$(pick_color error_container "$error")
surface_variant=$(pick_color surface_variant "$background")
surface_container=$(pick_color surface_container "$background")
surface_container_low=$(pick_color surface_container_low "$background")
on_background=$(pick_color on_background "$foreground")

cat > "$THEME_PATH" <<EOF
# Autogenerated by quickshell theme sync
background $background
foreground $foreground
selection_background $selection_bg
selection_foreground $selection_fg
cursor $cursor
cursor_text_color $on_primary
url_color $primary
active_border_color $primary
inactive_border_color $outline_variant
bell_border_color $error

color0 $surface_variant
color1 $error
color2 $secondary
color3 $tertiary
color4 $primary
color5 $secondary_container
color6 $tertiary_container
color7 $foreground
color8 $outline
color9 $error_container
color10 $primary
color11 $tertiary
color12 $primary
color13 $secondary
color14 $tertiary
color15 $on_background
EOF

block=$(cat <<'EOF'
# BEGIN_QUICKSHELL_THEME_SYNC
include quickshell-theme.conf
allow_remote_control yes
listen_on unix:/tmp/quickshell-kitty.sock
# END_QUICKSHELL_THEME_SYNC
EOF
)

if grep -q "$BEGIN_MARKER" "$KITTY_CONF"; then
  tmp_file="$KITTY_CONF.tmp"
  awk -v begin="$BEGIN_MARKER" -v end="$END_MARKER" -v block="$block" '
    $0 == begin { print block; inblock = 1; next }
    $0 == end { inblock = 0; next }
    !inblock { print }
  ' "$KITTY_CONF" > "$tmp_file"
  mv -f "$tmp_file" "$KITTY_CONF"
else
  printf '\n%s\n' "$block" >> "$KITTY_CONF"
fi

if [[ -n "$KITTY_BIN" ]]; then
  if command -v "$KITTY_BIN" >/dev/null 2>&1; then
    KITTY_BIN="$(command -v "$KITTY_BIN")"
  elif [[ ! -x "$KITTY_BIN" ]]; then
    KITTY_BIN=""
  fi
fi

if [[ -z "$KITTY_BIN" ]]; then
  if command -v kitty >/dev/null 2>&1; then
    KITTY_BIN="$(command -v kitty)"
  elif [[ -x /usr/bin/kitty ]]; then
    KITTY_BIN="/usr/bin/kitty"
  elif [[ -x /usr/local/bin/kitty ]]; then
    KITTY_BIN="/usr/local/bin/kitty"
  fi
fi

if [[ -n "$KITTY_BIN" ]]; then
  sockets=()
  if [[ -n "$KITTY_SOCKET" ]]; then
    sockets+=("$KITTY_SOCKET")
  fi

  listen_on_line="$(awk '/^[[:space:]]*listen_on[[:space:]]+/ {print $2; exit}' "$KITTY_CONF")"
  base_sock="${listen_on_line:-unix:/tmp/quickshell-kitty.sock}"
  if [[ "$base_sock" == unix:* ]]; then
    base_path="${base_sock#unix:}"
  else
    base_path="$base_sock"
  fi

  while IFS= read -r sock; do
    [[ -n "$sock" ]] || continue
    sockets+=("unix:$sock")
  done < <(ls -1t "${base_path}"* 2>/dev/null || true)

  if [[ ${#sockets[@]} -gt 0 ]]; then
    uniq_sockets=()
    for sock in "${sockets[@]}"; do
      seen=false
      for existing in "${uniq_sockets[@]}"; do
        if [[ "$existing" == "$sock" ]]; then
          seen=true
          break
        fi
      done
      if [[ "$seen" == "false" ]]; then
        uniq_sockets+=("$sock")
      fi
    done

    for sock in "${uniq_sockets[@]}"; do
      "$KITTY_BIN" @ --to "$sock" set-colors --all --configured "$THEME_PATH" >/dev/null 2>&1 || true
    done
  else
    "$KITTY_BIN" @ set-colors --all --configured "$THEME_PATH" >/dev/null 2>&1 || true
  fi
fi

echo "Updated kitty theme: $THEME_PATH"
